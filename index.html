<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mirror Maze</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.2.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
	<script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="src/common.js"></script>
  </head>

  <body>
    <a-scene id="scene" class="fullscreen" inspector="" keyboard-shortcuts="" screenshot="" vr-mode-ui="" shadow="autoUpdate: true; type:pcfsoft" fog="type: linear; near: 0; far: 1000; color: #000" >
      <a-assets>
        <img src="assets/images/door.png" id="asset_door">
        <img src="assets/images/wall.jpg" id="asset_wall">
        <img src="assets/images/roof.jpg" id="asset_roof">
        <img src="assets/images/ground.jpg" id="asset_ground">
        <img src="assets/images/instruction.jpg" id="asset_instruction">
		<img src="assets/images/night_sky.jpg" id="asset_sky">

		<a-asset-item id="asset_altar" src="assets/3d/altar_circle/scene.gltf"></a-asset-item>
		<a-asset-item id="asset_price" src="assets/3d/medieval_gate/scene.gltf"></a-asset-item>
		<a-asset-item id="asset_reload" src="assets/3d/garden_baby_angel_statue/scene.gltf"></a-asset-item>
      </a-assets>
	  <a-sky src="#asset_sky"></a-sky>
	  <!-- <a-light  type="hemisphere" color="#fff" intensity="1.5"></a-light> -->
      <a-camera 
        id="camera" 
        position="0 1.6 -2"
        look-controls
        wasd-controls="acceleration: 100">
		<a-light type="point" color="#fff" intensity="2"></a-light>
        <a-cursor 
          id="cursor" 
          position="0 0 -1" 
          fuse="true" 
          fuseTimeout="500"
          raycaster="objects: .cursor-listener"
          geometry="radiusInner: 0.015; radiusOuter: 0.025" 
          color="#00e2ff"></a-cursor>
        <a-text value="Time" height="0.001" material="color:#ff3232" position="-0.1 -0.7 -1" id="board"></a-entity>
        <a-text value="" height="0.001" material="color:#f4ff61" position="-0.3 0 -1" id="winner"></a-entity>
		
      </a-camera>
    </a-scene>
    
    <script>
		var maze;
		var seconds;
		var counter;

		function init(width, height) {
		clearInterval(counter);
		maze = new Array(parseInt(height));
		for (var i = 0; i < maze.length; i++) {
			maze[i] = [].repeat(0, width);
		}

		buildPath(maze, [0, 0]);
		if (typeof QueryString.maze == "undefined") {
			window.location.hash +=
			"&maze=" + LZString.compressToBase64(JSON.stringify(maze));
		} else {
			maze = JSON.parse(LZString.decompressFromBase64(QueryString.maze));
		}
		paintMaze(maze);
		// var winner = document.getElementById("winner");
		// var attr_text = winner.getAttribute("text");
		// attr_text = "";
		// winner.setAttribute("text", attr_text);
		seconds = 0;
		counter = setInterval(function () {
			let board = document.getElementById("board");
			let attr_text = board.getAttribute("value");
			let scene = document.getElementById("scene");
			attr_text = seconds++;
			let sec = attr_text;
			board.setAttribute("value", attr_text);
			scene.setAttribute("fog", "type: linear; near: 0; far: " + (1000 - attr_text) + "; color: #000");
		}, 1000);
		}


		var width = QueryString.width;
		var height = QueryString.height;
		if (typeof width == "undefined") {
		width = 18;
		}
		if (typeof height == "undefined") {
		height = 14;
		}
		init(width, height);

		AFRAME.registerComponent("camera-cube-env", {
		schema: {
			resolution: { type: "number", default: 128 },
			distance: { type: "number", default: 100 },
			interval: { type: "number", default: 100 },
			matoverride: { type: "boolean", default: false },
			metalness: { type: "float", default: 1.0 },
			roughness: { type: "float", default: 0.0 },
			repeat: { type: "boolean", default: true },
		},

		multiple: false,

		init: function () {
			this.tick = AFRAME.utils.throttleTick(this.tick, this.data.interval, this);

			this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(
			this.data.resolution,
			{
				format: THREE.RGBFormat,
				generateMipmaps: true,
				minFilter: THREE.LinearMipmapLinearFilter,
			}
			);
			this.cam = new THREE.CubeCamera(
			0.2,
			this.data.distance,
			this.cubeRenderTarget
			);

			this.el.object3D.add(this.cam);

			this.loaded = this.el.addEventListener("model-loaded", () => {
			const obj = this.el.getObject3D("mesh");
			obj.traverse((node) => {
				var myMesh = this.el.getObject3D("mesh");
				myMesh.visible = false;

				AFRAME.scenes[0].renderer.autoClear = true;
				var camVector = new THREE.Vector3();
				this.el.object3D.getWorldPosition(camVector);
				this.cam.position.copy(this.el.object3D.worldToLocal(camVector));
				this.cam.update(AFRAME.scenes[0].renderer, this.el.sceneEl.object3D);

				if (node.type.indexOf("Mesh") !== -1) {
				if (this.data.matoverride == true) {
					node.material.metalness = this.data.metalness;
					node.material.roughness = this.data.roughness;
				}
				node.material.envMap = this.cam.renderTarget.texture;
				node.material.needsUpdate = true;
				}
				myMesh.visible = true;
			});
			});
		},

		tick: function (t, dt) {
			if (!this.done) {
			this.redraw(this.cam, this.el, this.el.getObject3D("mesh"));
			if (!this.data.repeat) {
				this.done = true;
			}
			}
		},

		redraw: function (myCam, myEl, myMesh) {
			if (this.el.getObject3D("mesh") != null && AFRAME.scenes[0] != null) {
			myMesh.visible = false;

			AFRAME.scenes[0].renderer.autoClear = true;
			var camVector = new THREE.Vector3();
			myEl.object3D.getWorldPosition(camVector);
			myCam.position.copy(myEl.object3D.worldToLocal(camVector));
			myCam.update(AFRAME.scenes[0].renderer, myEl.sceneEl.object3D);
			if (myMesh) {
				myMesh.traverse(function (child) {
				if (child instanceof THREE.Mesh) {
					child.material.envMap = myCam.renderTarget.texture;
					child.material.needsUpdate = true;
				}
				});
			}
			myMesh.visible = true;
			}
		},

		update: function (oldData) {
			this.redraw(this.cam, this.el, this.el.getObject3D("mesh"));
		},

		remove: function () {
			this.loaded.remove();
		},

		pause: function () {},

		play: function () {},
		});

    </script>
  </body>
</html>
